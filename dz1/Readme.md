# LRU-кэш

## Условия задачи

На вход программе подаются:
- Число `N` - максимальный размер кэша (в записях)
- Число `Size` - максимальный размер кэша (в байтах)
- Набор строк одного из 2х видов

### Виды строк

1. `<q>\t<f1> <f2> <f3> ...`
   - `f1, f2, ...` - float-ы - "эмбединг", 64 числа
   - `q` - запрос, гарантированно без `\n`, `\r`, `\t`, `\0` и пробелов. Кодировка может быть utf-8 или cp1251. Гарантируется, что в cp1251 не будет символов `0x80 - 0xBF`.

2. `<q>`
   - `q` - тот же запрос

### Требуется

- Сделать LRU-кэш пар "запрос-эмбединг".
- При получении строки вида (а) обновляем пару `q+embed` в кэше. Печатаем `!STORED!`, если все ок и `!STORERR!`, если сохранить не удалось.
- При получении строки вида (б) распечатываем `embed` в формате `<f1> <f2> <f3> ...`. Если эмбеда по запросу нет, пишем `!NOEMBED!`.

### Требования

- При превышении `N` или `Size` (по сумме ключ+значение всех элементов) должны удаляться самые старые элементы (т.е. которые дольше всего не обновлялись/по которым дольше всего не запрашивали эмбед).
- Если пара `q+embed` не влезает в кэш по `N` или `Size` - не сохраняем.
- Если строка "битая" (невалидная кодировка, неправильные float-ы, ...) - не сохраняем.
- Сложности: все `O(1)` амортизированные, если не нужно удалять элементы; иначе - `O(k)`, где `k` - число удаляемых.

## Что нужно реализовать?

LRU кэш традиционно реализуется на паре: `unordered_map` + `list`. В самом кэше нужно реализовать методы, которые необходимы для реализации описанного функционала + `size()` - число элементов, `size_bytes()` - сумма размеров в байтах, `clear()`.

### Оценка (4-6)

- Используйте `std::unordered_map` и `std::list`.
- LRU-кэш должен быть шаблонным по типам ключа и значения. По желанию - возможность принять `HashT`, `ComparatorT`.

### Оценка (7-8)

- Нужно реализовать самостоятельно `unordered_map` - с закрытой адресацией (не цепочки, хранение элементов внутри выделенного массива), в качестве списка `std::list`.
- `map` должна быть шаблонной по ключу и значению. По желанию - возможность принять `HashT`, `ComparatorT`.
- Внутри мапы должны быть реализованы итераторы (обычный и const), `empty()`, `size()`, `clear()`, `reserve()`, `load_factor()`, `max_load_factor()`, `operator[]()`, `find()`, `count()`, `insert()`, `erase()` с семантикой, аналогичной STL.
- Мапа должна верно реализовывать RAII.

### Оценка (9-10)

- Та же `unordered_map` + интрузивный список.
- Список, очевидно, будет шаблонным. Можно вдохновляться [Boost Intrusive List](https://www.boost.org/doc/libs/1_67_0/doc/html/intrusive/list.html), который "using the public member hook...".
- Внутри списка должны быть реализованы итераторы (обычный и const), `empty()`, `size()`, `clear()`, `front()`, `back()`, `push/pop_front()`, `push/pop_back()`, `insert()`, `splice()` с семантикой, аналогичной STL.

## Оформление

Решение должно быть оформлено в виде файлов:
- `lru.hpp` - сам кэш
- `main.cpp` - программа, реализующая обработку потока запросов с помощью LRU-кэша.
- `test_lru.cpp` - unit-тесты lru-кэша

Далее, если выбрано решение на оценку 7-8:
- `hashtable.hpp` - реализация хэш-таблицы
- `test_hashtable.cpp` - юнит-тесты хэш-таблицы

Далее, если выбрано решение на оценку 9-10:
- `intrusive_list.hpp` - реализация интрузивного списка
- `test_intrusive_list.cpp` - юнит-тесты интрузивного списка

## Как будет проверяться?

(!) В проверяющей системе будет установлено `icu`.

### Шаги проверки

1. **Форматирование кода**

   ```sh
   clang-format-10 --dry-run --Werror --style=file *.cpp *.hpp
   ```

2. **Компиляция и тестирование LRU-кэша**

   ```sh
   g++ -fprofile-arcs -ftest-coverage \
       -g -O0 -fsanitize=address -std=c++20 \
       -Wall -Werror -Wextra test_lru.cpp -o test_lru
   ./test_lru
   ```

   Должен проходить, а покрытие файлов `lru.hpp` должно составить >= 90%.

3. **Компиляция и тестирование основной программы**

   ```sh
   g++ -std=c++20 -O2 -fsanitize=address \
       -Wall -Werror -Wextra main.cpp -o main
   ./main
   ```

   Проверяются тесты с `stdin`, как в обычном спортивном программировании.

4. **Компиляция и тестирование хэш-таблицы (7-8 баллов)**

   ```sh
   cp hashtable.hpp test_hashtable.cpp $TMP_DIR && cd $TMP_DIR
   g++ --coverage -g -O0 -fsanitize=address -std=c++20 \
       -Wall -Werror -Wextra test_hashtable.cpp -o test_hashtable
   ./test_hashtable
   rm -rf $TMP_DIR
   ```

   Должен проходить, а покрытие файла `hashtable.hpp` должно составить >= 90%.

5. **Компиляция и тестирование интрузивного списка (9-10 баллов)**

   То же, что в п. 3, но для `intrusive_list.hpp` и `test_intrusive_list.cpp`.

## Критерии оценки

За основу берется оценка вашего решения по верхнему уровню (т.е. 6, 8 или 10), далее с него могут сниматься баллы:
- 0 баллов сразу: копирование кода (обоим), решение не выполняет поставленные задачи в условии.
- -1 балл: дублирование кода, отсутствие разделения на функции.
- -1 балл: необоснованные копирования, неиспользование move-семантики и т.п.
- -1 балл: нечитаемый код, непонятные названия функций, переменных и т.п.
- -1 балл: неоптимальные алгоритмы (кроме ситуации неверных асимптотик - тогда задание считается невыполненным).
- -2 балла: допущенные UB, "вылет" за границы массива (если вдруг не поймал санитайзер), прочие грубые логические ошибки.

### Проверка на покрытие

   ```bash
   mkdir build
   cd build
   cmake ..
   make
   ```

   ```bash
   ./test_intrusive_list.hpp
   ./test_lru.cpp
   ```

   ```bash
   lcov --capture --directory . --output-file coverage.info
   ```
  
   ```bash
   genhtml coverage.info --output-directory coverage
   ```
     
   ```bash
   xdg-open out/index.html
   ```
![image](https://github.com/user-attachments/assets/6b9c3abc-4217-4ae8-a307-48494781b820)
